{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ApplySyntax Overview ApplySyntax is a plugin for Sublime Text that allows you to detect and apply the syntax of files that might not otherwise be detected properly. For example, files with the .rb extension are usually Ruby files, but when they are found in a Rails project, they could be RSpec spec files, Cucumber step files, Ruby on Rails files (controllers, models, etc), or just plain Ruby files. This is actually the problem I was trying to solve when I started working on this plugin. Credits DetectSyntax was originally created by phillipkoebbe. In his words, these are his credits: It all started by forking the plugin created by JeanMertz (1) . I modified it quite extensively until I ended up with something entirely my own (2) . @maxim and @omarramos commented on the gist and suggested it should be part of Package Control. As I had created it solely for my own consumption, it seemed a bit \"hard-coded\" to be valuable as a package, but then I took a look at SetSyntax (3) . and saw how using settings would make it very flexible. That set me on the path that led to DetectSyntax. \u2013 phillipkoebbe Installation The recommended installation method is via Package Control. Learn more here: https://sublime.wbond.net/ .","title":"About ApplySyntax"},{"location":"#applysyntax","text":"","title":"ApplySyntax"},{"location":"#overview","text":"ApplySyntax is a plugin for Sublime Text that allows you to detect and apply the syntax of files that might not otherwise be detected properly. For example, files with the .rb extension are usually Ruby files, but when they are found in a Rails project, they could be RSpec spec files, Cucumber step files, Ruby on Rails files (controllers, models, etc), or just plain Ruby files. This is actually the problem I was trying to solve when I started working on this plugin.","title":"Overview"},{"location":"#credits","text":"DetectSyntax was originally created by phillipkoebbe. In his words, these are his credits: It all started by forking the plugin created by JeanMertz (1) . I modified it quite extensively until I ended up with something entirely my own (2) . @maxim and @omarramos commented on the gist and suggested it should be part of Package Control. As I had created it solely for my own consumption, it seemed a bit \"hard-coded\" to be valuable as a package, but then I took a look at SetSyntax (3) . and saw how using settings would make it very flexible. That set me on the path that led to DetectSyntax. \u2013 phillipkoebbe","title":"Credits"},{"location":"#installation","text":"The recommended installation method is via Package Control. Learn more here: https://sublime.wbond.net/ .","title":"Installation"},{"location":"installation/","text":"Installation Package Control The recommended way to install ApplySyntax is via Package Control . Package Control will install the correct branch on your system and keep it up to date. Ensure Package Control is installed. Instructions are found here . In Sublime Text, press Ctrl \uff0b Shift \uff0b P (Win, Linux) or Cmd \uff0b Shift \uff0b P (macOS) to bring up the quick panel and start typing Package Control: Install Package . Select the command and it will show a list of installable plugins. Start typing ApplySyntax ; when you see it, select it. Restart to be sure everything is loaded proper. Enjoy! Manual Installation Warning This is not the recommended way to install ApplySyntax for the average user. Installing this way will not get automatically updated. If you are forking for a pull request, you should just clone ApplySyntax and run Package Control's Satisfy Dependency command to get all the dependencies. For those who want to install ApplySyntax without package control, here are the steps. It is understood that some people, for what ever reason, will prefer manual install and may even have legitimate reasons to do so. When going this route, you will have to keep all the packages updated yourself. Download the latest releases of the following dependencies and unpack or git clone in the Packages folder as shown below: teddy_beer_maniac/sublime-text-dependency-markupsafe -> markupsafe teddy_beer_maniac/sublime-text-dependency-jinja2 -> python-jinja2 packagecontrol/pygments -> pygments facelessuser/sublime-markdown-popups -> mdpopups facelessuser/sublime-markdown -> python-markdown Download and unpack, or git clone, the latest ApplySyntax release and unpack as ApplySyntax : facelessuser/ApplySyntax -> ApplySyntax Create a folder under Packages called 00-dependencies and under that folder create a file called 00-dependencies.py : Copy the following code to 00-dependencies.py (this code was taken from Package Control): import sys import os from os.path import dirname if os . name == 'nt' : from ctypes import windll , create_unicode_buffer import sublime if sys . version_info >= ( 3 ,): def decode ( path ): return path def encode ( path ): return path if os . path . basename ( __file__ ) == 'sys_path.py' : pc_package_path = dirname ( dirname ( __file__ )) # When loaded as a .sublime-package file, the filename ends up being # Package Control.sublime-package/Package Control.package_control.sys_path else : pc_package_path = dirname ( __file__ ) st_version = u '3' else : def decode ( path ): if not isinstance ( path , unicode ): path = path . decode ( sys . getfilesystemencoding ()) return path def encode ( path ): if isinstance ( path , unicode ): path = path . encode ( sys . getfilesystemencoding ()) return path pc_package_path = decode ( os . getcwd ()) st_version = u '2' st_dir = dirname ( dirname ( pc_package_path )) def add ( path , first = False ): \"\"\" Adds an entry to the beginning of sys.path, working around the fact that Python 2.6 can't import from non-ASCII paths on Windows. :param path: A unicode string of a folder, zip file or sublime-package file to add to the path :param first: If the path should be added at the beginning \"\"\" if os . name == 'nt' : # Work around unicode path import issue on Windows with Python 2.6 buf = create_unicode_buffer ( 512 ) if windll . kernel32 . GetShortPathNameW ( path , buf , len ( buf )): path = buf . value enc_path = encode ( path ) if os . path . exists ( enc_path ): if first : try : sys . path . remove ( enc_path ) except ( ValueError ): pass sys . path . insert ( 0 , enc_path ) elif enc_path not in sys . path : sys . path . append ( enc_path ) def remove ( path ): \"\"\" Removes a path from sys.path if it is present :param path: A unicode string of a folder, zip file or sublime-package file \"\"\" try : sys . path . remove ( encode ( path )) except ( ValueError ): pass if os . name == 'nt' : buf = create_unicode_buffer ( 512 ) if windll . kernel32 . GetShortPathNameW ( path , buf , len ( buf )): path = buf . value try : sys . path . remove ( encode ( path )) except ( ValueError ): pass def generate_dependency_paths ( name ): \"\"\" Accepts a dependency name and generates a dict containing the three standard import paths that are valid for the current machine. :param name: A unicode string name of the dependency :return: A dict with the following keys: - 'ver' - 'plat' - 'arch' \"\"\" packages_dir = os . path . join ( st_dir , u 'Packages' ) dependency_dir = os . path . join ( packages_dir , name ) ver = u 'st %s ' % st_version plat = sublime . platform () arch = sublime . arch () return { 'all' : os . path . join ( dependency_dir , 'all' ), 'ver' : os . path . join ( dependency_dir , ver ), 'plat' : os . path . join ( dependency_dir , u ' %s _ %s ' % ( ver , plat )), 'arch' : os . path . join ( dependency_dir , u ' %s _ %s _ %s ' % ( ver , plat , arch )) } def add_dependency ( name , first = False ): \"\"\" Accepts a dependency name and automatically adds the appropriate path to sys.path, if the dependency has a path for the current platform and architecture. :param name: A unicode string name of the dependency :param first: If the path should be added to the beginning of the list \"\"\" dep_paths = generate_dependency_paths ( name ) for path in dep_paths . values (): if os . path . exists ( encode ( path )): add ( path , first = first ) add_dependency ( 'pygments' ) add_dependency ( 'markupsafe' ) add_dependency ( 'python-markdown' ) add_dependency ( 'python-jinja2' ) add_dependency ( 'mdpopups' ) Restart and enjoy. Git Cloning Quit Sublime Text. Open a terminal and enter the following. For dependencies, replace the URL with the appropriate URL, and the appropriate folder to check it out to: cd /path/to/Sublime Text 3/Packages git clone https://github.com/facelessuser/ApplySyntax.git ApplySyntax Restart Sublime Text.","title":"Installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#package-control","text":"The recommended way to install ApplySyntax is via Package Control . Package Control will install the correct branch on your system and keep it up to date. Ensure Package Control is installed. Instructions are found here . In Sublime Text, press Ctrl \uff0b Shift \uff0b P (Win, Linux) or Cmd \uff0b Shift \uff0b P (macOS) to bring up the quick panel and start typing Package Control: Install Package . Select the command and it will show a list of installable plugins. Start typing ApplySyntax ; when you see it, select it. Restart to be sure everything is loaded proper. Enjoy!","title":"Package Control"},{"location":"installation/#manual-installation","text":"Warning This is not the recommended way to install ApplySyntax for the average user. Installing this way will not get automatically updated. If you are forking for a pull request, you should just clone ApplySyntax and run Package Control's Satisfy Dependency command to get all the dependencies. For those who want to install ApplySyntax without package control, here are the steps. It is understood that some people, for what ever reason, will prefer manual install and may even have legitimate reasons to do so. When going this route, you will have to keep all the packages updated yourself. Download the latest releases of the following dependencies and unpack or git clone in the Packages folder as shown below: teddy_beer_maniac/sublime-text-dependency-markupsafe -> markupsafe teddy_beer_maniac/sublime-text-dependency-jinja2 -> python-jinja2 packagecontrol/pygments -> pygments facelessuser/sublime-markdown-popups -> mdpopups facelessuser/sublime-markdown -> python-markdown Download and unpack, or git clone, the latest ApplySyntax release and unpack as ApplySyntax : facelessuser/ApplySyntax -> ApplySyntax Create a folder under Packages called 00-dependencies and under that folder create a file called 00-dependencies.py : Copy the following code to 00-dependencies.py (this code was taken from Package Control): import sys import os from os.path import dirname if os . name == 'nt' : from ctypes import windll , create_unicode_buffer import sublime if sys . version_info >= ( 3 ,): def decode ( path ): return path def encode ( path ): return path if os . path . basename ( __file__ ) == 'sys_path.py' : pc_package_path = dirname ( dirname ( __file__ )) # When loaded as a .sublime-package file, the filename ends up being # Package Control.sublime-package/Package Control.package_control.sys_path else : pc_package_path = dirname ( __file__ ) st_version = u '3' else : def decode ( path ): if not isinstance ( path , unicode ): path = path . decode ( sys . getfilesystemencoding ()) return path def encode ( path ): if isinstance ( path , unicode ): path = path . encode ( sys . getfilesystemencoding ()) return path pc_package_path = decode ( os . getcwd ()) st_version = u '2' st_dir = dirname ( dirname ( pc_package_path )) def add ( path , first = False ): \"\"\" Adds an entry to the beginning of sys.path, working around the fact that Python 2.6 can't import from non-ASCII paths on Windows. :param path: A unicode string of a folder, zip file or sublime-package file to add to the path :param first: If the path should be added at the beginning \"\"\" if os . name == 'nt' : # Work around unicode path import issue on Windows with Python 2.6 buf = create_unicode_buffer ( 512 ) if windll . kernel32 . GetShortPathNameW ( path , buf , len ( buf )): path = buf . value enc_path = encode ( path ) if os . path . exists ( enc_path ): if first : try : sys . path . remove ( enc_path ) except ( ValueError ): pass sys . path . insert ( 0 , enc_path ) elif enc_path not in sys . path : sys . path . append ( enc_path ) def remove ( path ): \"\"\" Removes a path from sys.path if it is present :param path: A unicode string of a folder, zip file or sublime-package file \"\"\" try : sys . path . remove ( encode ( path )) except ( ValueError ): pass if os . name == 'nt' : buf = create_unicode_buffer ( 512 ) if windll . kernel32 . GetShortPathNameW ( path , buf , len ( buf )): path = buf . value try : sys . path . remove ( encode ( path )) except ( ValueError ): pass def generate_dependency_paths ( name ): \"\"\" Accepts a dependency name and generates a dict containing the three standard import paths that are valid for the current machine. :param name: A unicode string name of the dependency :return: A dict with the following keys: - 'ver' - 'plat' - 'arch' \"\"\" packages_dir = os . path . join ( st_dir , u 'Packages' ) dependency_dir = os . path . join ( packages_dir , name ) ver = u 'st %s ' % st_version plat = sublime . platform () arch = sublime . arch () return { 'all' : os . path . join ( dependency_dir , 'all' ), 'ver' : os . path . join ( dependency_dir , ver ), 'plat' : os . path . join ( dependency_dir , u ' %s _ %s ' % ( ver , plat )), 'arch' : os . path . join ( dependency_dir , u ' %s _ %s _ %s ' % ( ver , plat , arch )) } def add_dependency ( name , first = False ): \"\"\" Accepts a dependency name and automatically adds the appropriate path to sys.path, if the dependency has a path for the current platform and architecture. :param name: A unicode string name of the dependency :param first: If the path should be added to the beginning of the list \"\"\" dep_paths = generate_dependency_paths ( name ) for path in dep_paths . values (): if os . path . exists ( encode ( path )): add ( path , first = first ) add_dependency ( 'pygments' ) add_dependency ( 'markupsafe' ) add_dependency ( 'python-markdown' ) add_dependency ( 'python-jinja2' ) add_dependency ( 'mdpopups' ) Restart and enjoy.","title":"Manual Installation"},{"location":"installation/#git-cloning","text":"Quit Sublime Text. Open a terminal and enter the following. For dependencies, replace the URL with the appropriate URL, and the appropriate folder to check it out to: cd /path/to/Sublime Text 3/Packages git clone https://github.com/facelessuser/ApplySyntax.git ApplySyntax Restart Sublime Text.","title":"Git Cloning"},{"location":"usage/","text":"User Guide Overview ApplySyntax is based on the idea of creating rules for applying certain syntaxes to specific files. You define the rules, the plugin checks them. The first one to pass wins. ApplySyntax allows you to create your own custom rules. The easiest way to get started is to press Ctrl \uff0b Shift \uff0b P (Win, Linux) or Cmd \uff0b Shift \uff0b P (macOS) to bring up the quick panel and start typing ApplySyntax: Settings . Alternatively, you can create a settings file called ApplySyntax.sublime-settings in your Packages/User folder. You can override the default settings in Packages/ApplySyntax/ApplySyntax.sublime-settings by setting them in your Packages/User/ApplySyntax.sublime-settings file. You can override any setting to meet your needs. To prepend rules to the default rule set, you can create a key called syntaxes (modifying default_syntaxes will wipe out all the default rules and is not recommended as you won't get the latest updates). Commands When create syntax rules, you will need to use the syntax file name, not the name that shows in the status bar. A few commands have been added to make it easy to determine what to put into a syntax rule. ApplySyntax: Browse Syntaxes This command will show a quick panel of all the syntaxes in your Sublime Text install. You can fuzzy search them, and when you select one, it will be copied to the clipboard in a form compatible to be used in a syntax rule. Simply paste it in the rule. New 4.0 ApplySyntax: Browse Syntaxes is new in 4.0. ApplySyntax: Copy Current Syntax to Clipboard This command will copy the current syntax in the active view to your clipboard in a form that is compatible to be used in a syntax rule. Simply paste it in the rule. New 4.0 ApplySyntax: Copy Current Syntax to Clipboard is new in 4.0. Creating Rules Each rule is a dictionary within the syntax array. Let's take a look at the top level parameters. Syntax The syntax attribute is the syntax file that will be applied to a view which meets the criteria defined in the rule. For syntax files you must specify the path to the syntax file. The plugin is capable of supporting multiple levels of folder nesting if you need it to. For example, if you had all of your tmLanguage files for Rails organized in a folder like this: Packages/Rails/Language/*.tmLanguage , and you were looking to use the Ruby Haml.tmLanguage file, the path to name translation would simply be: Packages/Rails/Language/Ruby Haml.tmLanguage \u2192 Rails/Language/Ruby Haml . \"syntax\" : \"Rails/Language/Ruby Haml\" Notice that the paths are relative to the Packages folder. Also, notice that we don't specify the extension. Sublime Text in build 3084 added a new language syntax with the extension sublime-syntax . In Sublime builds >= 3084, ApplySyntax will first default to sublime-syntax and fall back to tmLanguage if it cannot find the the other format. If you want to force the syntax, just specify the extension; the extension must be either sublime-syntax or tmLanguage . \"syntax\" : \"Rails/Language/Ruby Haml.tmLanguage\" If it is desirable for the syntax rule to reference multiple tmLanguage files because it is not known which package will be on a machine, you can set the syntax as an array of syntaxes as shown in the following example. The first one found will be used. \"syntax\" : [ \"RSpec/RSpec\" , \"RSpec (snippets and syntax)/Syntaxes/RSpec\" ] Notice that each syntax file has a different path since they come from completely different plugins. Lastly, if using Package Control, it is likely that most, if not all, of your packages will be zipped with the extension .sublime-package in the Installed Packages folder instead of Packages . These will be handled exactly like plugins installed under Packages . The one difference is that you treat the zip bundle as a folder without the .sublime-package extension. So if we had a syntax file located in a zipped bundle: Installed Packages/Rails.sublime-package/Language/Ruby Haml.tmLanguage \u2192 Rails/Language/Ruby Haml . \"syntax\" : \"Rails/Language/Ruby Haml\" Extensions The extensions attribute is used to define extensions to apply a syntax to. extensions is an array of strings where each string is an extension. No . is needed when defining extensions, unless it is desired to target a dot file like .gitignore , then you would include the . . { \"syntax\" : \"YAML/YAML\" , \"extensions\" : [ \".gemrc\" , \"yml\" , \"yml.dist\" ] }, extensions is evaluated before all other rules, and it never takes part in \" match all \" rule sets as it is run separate from the normal rule sets; if an extension is matched here, all other rules will be skipped. An added benefit of extensions , if you are using ST3 and set add_exts_to_lang_settings to true , is that ApplySyntax will add the extensions to the specified syntax language's settings file in your User folder. By doing this, Sublime Text will be able to show the associated icon for the file type in the sidebar. Apply syntax will also create a file ApplySyntax.ext-list in your User folder and track which extension it added so that if you remove a rule, ApplySyntax will only remove the extensions it added to the language file in question. If you do not like this functionality, you can simply disable add_exts_to_lang_settings by setting it to false . Note add_exts_to_lang_settings will not be applied to extensions found in a project specific rule , as project specific rules are not global, but the effects of add_exts_to_lang_settings are global. Match match is a setting that you either include or omit. When included, you set it to all . When set, all rules defined must be met for a match to be considered successful. match ignores the extensions key as extensions never take part in \"match all\" rule sets. If you want to include an extension rule in a \"match all\" rule set, then a file_path rule should be used. \"match\" : \"all\" So in this case, all the rules must match for the syntax to be applied: \"syntax\" : \"Handlebars/Handlebars\" , \"match\" : \"all\" , \"rules\" : [ { \"file_path\" : \".*\\\\.html$\" }, { \"contains\" : \"<script [^>]*type=\\\"text\\\\/x-handlebars\\\"[^>]*>\" } ] In this case, there is no match key, so only one rule needs to match: { \"syntax\" : \"Ruby/Ruby\" , \"rules\" : [ { \"file_path\" : \".*/Gemfile$\" }, { \"file_path\" : \".*/Capfile$\" }, { \"file_path\" : \".*/Guardfile$\" }, { \"file_path\" : \".*/[Rr]akefile$\" }, { \"file_path\" : \".*/Berksfile$\" }, { \"file_path\" : \".*/[Cc]heffile$\" }, { \"file_path\" : \".*/Thorfile$\" }, { \"file_path\" : \".*/Podfile$\" }, { \"file_path\" : \".*/config.ru$\" }, { \"file_path\" : \".*/Vagrantfile(/..*)?$\" }, { \"file_path\" : \".*\\\\.thor$\" }, { \"file_path\" : \".*\\\\.rake$\" }, { \"file_path\" : \".*\\\\.simplecov$\" }, { \"file_path\" : \".*\\\\.jbuilder$\" }, { \"file_path\" : \".*\\\\.rb$\" }, { \"file_path\" : \".*\\\\.podspec$\" }, { \"file_path\" : \".*\\\\.rabl$\" }, { \"interpreter\" : \"ruby\" } ] }, Rules rules is an array of rules that can be used to target specific files with your defined syntax file. The rules are processed until the first rule matches, so order your rules in a way that makes sense to you. Globmatch Rule A globmatch rule defines a glob pattern to match a file path against. Regex is more powerful, but often, a glob pattern can be far less cumbersome and easier to specify patterns that work cross platform. ApplySyntax uses the wcmatch library with the following flags enabled: GLOBSTAR : Allows you to match 0 or more directories with ** . BRACE : Allows you to use Bash style brace expansions for patterns ( a{b,c} \u2192 ab ac ). EXTGLOB : Allows you to use extended glob patterns such as @(file1|file2) , etc. NEGATE : Allows you to use exclusion patterns that filter inclusion patterns ( [ '**/*.py' , '!**/bad.py' ] ). DOTGLOB : Allows * and other such patterns to match file names that start with . . globmatch rule takes either a string pattern or list of strings patterns. You do not have to specify Windows paths with \\\\ , just use / . { \"globmatch\" : \"**/*.py\" } When providing a list, all patterns are evaluated together. This allows you to apply excludes: { \"globmatch\" : [ \"**/*.py\" , \"!**/bad.py\" ]} If necessary, you can specify case sensitivity: { \"globmatch\" : \"**/*.py\" , \"case\" : true } New 4.0 globmatch rules are new in 4.0. File Path Rule A file_path rule defines a regex to match against the complete file path. The pattern is always anchored to the beginning of the path, as if there were an implicit ^ \u2014 so the pattern /a/b/c will match the file /a/b/c/foo.py , but not the file /x/y/z/a/b/c/foo.py . (You may include an explicit ^ at the beginning of the pattern, as some of the default rules do \u2014 but the result is the same either way.) For backwards compatibility with older versions of ApplySyntax, the rule name file_name is also accepted, and functions exactly like file_path . { \"file_path\" : \".*\\\\.xml(\\\\.dist)?$\" }, Changed 4.0 On Windows systems, paths are now normalized to from using \\ to / . This makes creating patterns for cross platform use much easier, but it may break some existing rules in the short term. First Line Rule A first_line rule allows you to check whether the first line of the file's content matches a given regex. As with file_path rules , the pattern is always anchored to the beginning of the line. { \"first_line\" : \"^<\\\\?xml\" }, Interpreter (Shebang) An interpreter rule does the same thing as a first_line rule that uses a regex to match an interpreter directive (shebang). The difference being that ApplySyntax will construct the regex for you. So a first_line rule: { \"first_line\" : \"^#\\\\!(?:.+)ruby\" } Can be simplified as: { \"interpreter\" : \"ruby\" } For backwards compatibility with older versions of ApplySyntax, the rule name binary is also accepted, and functions exactly like interpreter . Function Rule This is an example of using a custom function to decide whether or not to apply a syntax. This is done via ApplySyntax plugins. The plugin file should be under a plugin folder. The function rule takes two parameters. The first is source and is the plugin source file. It is defined as if you were importing a python plugin. If you had a plugin in Packages/ApplySyntax/as_plugins/is_rails_file.py , it would be defined under source as ApplySyntax.as_plugins.is_rails_file . Function rules still support the legacy way: ApplySyntax/as_plugins/is_rails_file , but it is recommended to use the dot notation as it makes more sense from a Python import perspective. The second parameter is args and is optional. args is a dictionary of the keyword arguments the function rule plugin accepts. The plugin must have a function defined as syntax_test . syntax_test will be the function called within the plugin file and accepts an argument file_path (which is the full path to the file being evaluated), and any custom keyword arguments desired by the user. The plugin must return either True or False . { \"function\" : { \"source\" : \"User.plugins.myplugin\" , \"args\" : { 'foo' : \"bar\" }}} Example: def syntax_test ( file_path , foo ): # Some test logic return False # True or False Tip When placing a function rule module in a package, it is advised to put it in a sub-folder. The sub-folder does not need an __init__.py , it just needs your module(s). Content Rule Sometimes a file name or first line search is just not enough and maybe a function rule is overkill. In this case, maybe searching the content of a file can be enough. You can search a file's content with regex for a specific token via the contains rule. { \"contains\" : \"<script [^>]*type=\\\"text\\\\/x-handlebars\\\"[^>]*>\" } Tip It is recommended to pair contains rules with other rules via the \"match\" : \"all\" option to ensure you don't search every file (which can significantly slow down the editor); this will also help ensure get more reliable matches. If pairing with other rules as dependencies, it is advised to pair the contains rule after the other required rule(s) to ensure you search the content of as few files as possible. Also, try to use very specific regex to ensure you don't get false positives. Extension Trimming Sometimes a file may have a trailing extension that prevents it from matching a rule, but if it was trimmed off, it would match. By creating an extension trimming rule, you target files that do not initial match and send them back through the pipe without it's last extension. Currently, an extension trimming rule only contains a file_path pattern. \"ext_trim\" : [{ \"file_path\" : \".*\\\\.py3\\\\.temp\" }] You can also use globmatch patterns: \"ext_trim\" : [{ \"globmatch\" : \"**/*.py3.temp\" }] So, if we had a file named test.py3.temp , it normally wouldn't match one of default rules. With the above rule, the file would be retried as test.py3 and would match the Python syntax rule. New 4.0 globmatch support was added in 4.0. Changed 4.0 On Windows systems, paths are now normalized to from using \\ to / . This makes creating patterns for cross platform use much easier, but it may break some existing rules in the short term. Project Specific Rules To define project specific syntaxes, just create a settings key in your project file (if it doesn't already exist) and then and an additional key under settings called project_syntaxes or project_ext_trim . project_syntaxes is an array; just add your syntax rules to project_syntaxes just like you would add them to syntaxes in your user settings file, and ApplySyntax will prepend the rules to the beginning of your defined rules. The order of rules is as follows: project \u2192 user \u2192 default. project_ext_trim is also an array, and you can trim rules just as you would to ext_trim in your user settings file. There is one difference between project specific rules and global rules. In project rules, the extensions key will not be applied to the associated syntax language settings file as project specific rules are not global, but language settings files are global. \"settings\" : { \"project_syntaxes\" : [ { \"syntax\" : \"XML/XML\" , \"rules\" : [ { \"file_path\" : \".*\\\\.xml(\\\\.dist)?$\" }, { \"first_line\" : \"^<\\\\?xml\" } ] } ], \"project_ext_trim\" : [ { \"file_path\" : \".*\\\\.file.temp\" } ] } Settings Options There are a couple of general settings found in ApplySyntax.sublime-settings . Re-Raise Exceptions If an exception occurs when processing a function, this will re-raised the captured exception in Sublime's console so the user get feedback. This is really only useful to those writing functions. The average user shouldn't need this. By default, the setting will be set to false . \"reraise_exceptions\" : false , New File Syntax If you want to have a syntax applied when new files are created, set new_file_syntax to the name of the syntax to use. The format is exactly the same as the syntax parameter in the syntax rules mentioned earlier. For example, if you want to have a new file use JavaScript syntax, set new_file_syntax to JavaScript/JavaScript . The default is false . \"new_file_syntax\" : \"JavaScript/JavaScript\" , Add Extensions to Language Settings To enable adding defined extensions to language settings, just set add_exts_to_lang_settings to true . See Extensions for more info. \"add_exts_to_lang_settings\" : true , Troubleshooting and Debugging By default, the debug setting is turned on so that users have some form of visual feedback in the console that ApplySyntax is working. This can be turned off by setting debug to false . If developing, you can set debug to verbose to get even more info in the console. // Control level of logging in the console. // (true|false|\"verbose\") \"debug\" : true ,","title":"User Guide"},{"location":"usage/#user-guide","text":"","title":"User Guide"},{"location":"usage/#overview","text":"ApplySyntax is based on the idea of creating rules for applying certain syntaxes to specific files. You define the rules, the plugin checks them. The first one to pass wins. ApplySyntax allows you to create your own custom rules. The easiest way to get started is to press Ctrl \uff0b Shift \uff0b P (Win, Linux) or Cmd \uff0b Shift \uff0b P (macOS) to bring up the quick panel and start typing ApplySyntax: Settings . Alternatively, you can create a settings file called ApplySyntax.sublime-settings in your Packages/User folder. You can override the default settings in Packages/ApplySyntax/ApplySyntax.sublime-settings by setting them in your Packages/User/ApplySyntax.sublime-settings file. You can override any setting to meet your needs. To prepend rules to the default rule set, you can create a key called syntaxes (modifying default_syntaxes will wipe out all the default rules and is not recommended as you won't get the latest updates).","title":"Overview"},{"location":"usage/#commands","text":"When create syntax rules, you will need to use the syntax file name, not the name that shows in the status bar. A few commands have been added to make it easy to determine what to put into a syntax rule.","title":"Commands"},{"location":"usage/#applysyntax-browse-syntaxes","text":"This command will show a quick panel of all the syntaxes in your Sublime Text install. You can fuzzy search them, and when you select one, it will be copied to the clipboard in a form compatible to be used in a syntax rule. Simply paste it in the rule. New 4.0 ApplySyntax: Browse Syntaxes is new in 4.0.","title":"ApplySyntax: Browse Syntaxes"},{"location":"usage/#applysyntax-copy-current-syntax-to-clipboard","text":"This command will copy the current syntax in the active view to your clipboard in a form that is compatible to be used in a syntax rule. Simply paste it in the rule. New 4.0 ApplySyntax: Copy Current Syntax to Clipboard is new in 4.0.","title":"ApplySyntax: Copy Current Syntax to Clipboard"},{"location":"usage/#creating-rules","text":"Each rule is a dictionary within the syntax array. Let's take a look at the top level parameters.","title":"Creating Rules"},{"location":"usage/#syntax","text":"The syntax attribute is the syntax file that will be applied to a view which meets the criteria defined in the rule. For syntax files you must specify the path to the syntax file. The plugin is capable of supporting multiple levels of folder nesting if you need it to. For example, if you had all of your tmLanguage files for Rails organized in a folder like this: Packages/Rails/Language/*.tmLanguage , and you were looking to use the Ruby Haml.tmLanguage file, the path to name translation would simply be: Packages/Rails/Language/Ruby Haml.tmLanguage \u2192 Rails/Language/Ruby Haml . \"syntax\" : \"Rails/Language/Ruby Haml\" Notice that the paths are relative to the Packages folder. Also, notice that we don't specify the extension. Sublime Text in build 3084 added a new language syntax with the extension sublime-syntax . In Sublime builds >= 3084, ApplySyntax will first default to sublime-syntax and fall back to tmLanguage if it cannot find the the other format. If you want to force the syntax, just specify the extension; the extension must be either sublime-syntax or tmLanguage . \"syntax\" : \"Rails/Language/Ruby Haml.tmLanguage\" If it is desirable for the syntax rule to reference multiple tmLanguage files because it is not known which package will be on a machine, you can set the syntax as an array of syntaxes as shown in the following example. The first one found will be used. \"syntax\" : [ \"RSpec/RSpec\" , \"RSpec (snippets and syntax)/Syntaxes/RSpec\" ] Notice that each syntax file has a different path since they come from completely different plugins. Lastly, if using Package Control, it is likely that most, if not all, of your packages will be zipped with the extension .sublime-package in the Installed Packages folder instead of Packages . These will be handled exactly like plugins installed under Packages . The one difference is that you treat the zip bundle as a folder without the .sublime-package extension. So if we had a syntax file located in a zipped bundle: Installed Packages/Rails.sublime-package/Language/Ruby Haml.tmLanguage \u2192 Rails/Language/Ruby Haml . \"syntax\" : \"Rails/Language/Ruby Haml\"","title":"Syntax"},{"location":"usage/#extensions","text":"The extensions attribute is used to define extensions to apply a syntax to. extensions is an array of strings where each string is an extension. No . is needed when defining extensions, unless it is desired to target a dot file like .gitignore , then you would include the . . { \"syntax\" : \"YAML/YAML\" , \"extensions\" : [ \".gemrc\" , \"yml\" , \"yml.dist\" ] }, extensions is evaluated before all other rules, and it never takes part in \" match all \" rule sets as it is run separate from the normal rule sets; if an extension is matched here, all other rules will be skipped. An added benefit of extensions , if you are using ST3 and set add_exts_to_lang_settings to true , is that ApplySyntax will add the extensions to the specified syntax language's settings file in your User folder. By doing this, Sublime Text will be able to show the associated icon for the file type in the sidebar. Apply syntax will also create a file ApplySyntax.ext-list in your User folder and track which extension it added so that if you remove a rule, ApplySyntax will only remove the extensions it added to the language file in question. If you do not like this functionality, you can simply disable add_exts_to_lang_settings by setting it to false . Note add_exts_to_lang_settings will not be applied to extensions found in a project specific rule , as project specific rules are not global, but the effects of add_exts_to_lang_settings are global.","title":"Extensions"},{"location":"usage/#match","text":"match is a setting that you either include or omit. When included, you set it to all . When set, all rules defined must be met for a match to be considered successful. match ignores the extensions key as extensions never take part in \"match all\" rule sets. If you want to include an extension rule in a \"match all\" rule set, then a file_path rule should be used. \"match\" : \"all\" So in this case, all the rules must match for the syntax to be applied: \"syntax\" : \"Handlebars/Handlebars\" , \"match\" : \"all\" , \"rules\" : [ { \"file_path\" : \".*\\\\.html$\" }, { \"contains\" : \"<script [^>]*type=\\\"text\\\\/x-handlebars\\\"[^>]*>\" } ] In this case, there is no match key, so only one rule needs to match: { \"syntax\" : \"Ruby/Ruby\" , \"rules\" : [ { \"file_path\" : \".*/Gemfile$\" }, { \"file_path\" : \".*/Capfile$\" }, { \"file_path\" : \".*/Guardfile$\" }, { \"file_path\" : \".*/[Rr]akefile$\" }, { \"file_path\" : \".*/Berksfile$\" }, { \"file_path\" : \".*/[Cc]heffile$\" }, { \"file_path\" : \".*/Thorfile$\" }, { \"file_path\" : \".*/Podfile$\" }, { \"file_path\" : \".*/config.ru$\" }, { \"file_path\" : \".*/Vagrantfile(/..*)?$\" }, { \"file_path\" : \".*\\\\.thor$\" }, { \"file_path\" : \".*\\\\.rake$\" }, { \"file_path\" : \".*\\\\.simplecov$\" }, { \"file_path\" : \".*\\\\.jbuilder$\" }, { \"file_path\" : \".*\\\\.rb$\" }, { \"file_path\" : \".*\\\\.podspec$\" }, { \"file_path\" : \".*\\\\.rabl$\" }, { \"interpreter\" : \"ruby\" } ] },","title":"Match"},{"location":"usage/#rules","text":"rules is an array of rules that can be used to target specific files with your defined syntax file. The rules are processed until the first rule matches, so order your rules in a way that makes sense to you.","title":"Rules"},{"location":"usage/#globmatch-rule","text":"A globmatch rule defines a glob pattern to match a file path against. Regex is more powerful, but often, a glob pattern can be far less cumbersome and easier to specify patterns that work cross platform. ApplySyntax uses the wcmatch library with the following flags enabled: GLOBSTAR : Allows you to match 0 or more directories with ** . BRACE : Allows you to use Bash style brace expansions for patterns ( a{b,c} \u2192 ab ac ). EXTGLOB : Allows you to use extended glob patterns such as @(file1|file2) , etc. NEGATE : Allows you to use exclusion patterns that filter inclusion patterns ( [ '**/*.py' , '!**/bad.py' ] ). DOTGLOB : Allows * and other such patterns to match file names that start with . . globmatch rule takes either a string pattern or list of strings patterns. You do not have to specify Windows paths with \\\\ , just use / . { \"globmatch\" : \"**/*.py\" } When providing a list, all patterns are evaluated together. This allows you to apply excludes: { \"globmatch\" : [ \"**/*.py\" , \"!**/bad.py\" ]} If necessary, you can specify case sensitivity: { \"globmatch\" : \"**/*.py\" , \"case\" : true } New 4.0 globmatch rules are new in 4.0.","title":"Globmatch Rule"},{"location":"usage/#file-path-rule","text":"A file_path rule defines a regex to match against the complete file path. The pattern is always anchored to the beginning of the path, as if there were an implicit ^ \u2014 so the pattern /a/b/c will match the file /a/b/c/foo.py , but not the file /x/y/z/a/b/c/foo.py . (You may include an explicit ^ at the beginning of the pattern, as some of the default rules do \u2014 but the result is the same either way.) For backwards compatibility with older versions of ApplySyntax, the rule name file_name is also accepted, and functions exactly like file_path . { \"file_path\" : \".*\\\\.xml(\\\\.dist)?$\" }, Changed 4.0 On Windows systems, paths are now normalized to from using \\ to / . This makes creating patterns for cross platform use much easier, but it may break some existing rules in the short term.","title":"File Path Rule"},{"location":"usage/#first-line-rule","text":"A first_line rule allows you to check whether the first line of the file's content matches a given regex. As with file_path rules , the pattern is always anchored to the beginning of the line. { \"first_line\" : \"^<\\\\?xml\" },","title":"First Line Rule"},{"location":"usage/#interpreter-shebang","text":"An interpreter rule does the same thing as a first_line rule that uses a regex to match an interpreter directive (shebang). The difference being that ApplySyntax will construct the regex for you. So a first_line rule: { \"first_line\" : \"^#\\\\!(?:.+)ruby\" } Can be simplified as: { \"interpreter\" : \"ruby\" } For backwards compatibility with older versions of ApplySyntax, the rule name binary is also accepted, and functions exactly like interpreter .","title":"Interpreter (Shebang)"},{"location":"usage/#function-rule","text":"This is an example of using a custom function to decide whether or not to apply a syntax. This is done via ApplySyntax plugins. The plugin file should be under a plugin folder. The function rule takes two parameters. The first is source and is the plugin source file. It is defined as if you were importing a python plugin. If you had a plugin in Packages/ApplySyntax/as_plugins/is_rails_file.py , it would be defined under source as ApplySyntax.as_plugins.is_rails_file . Function rules still support the legacy way: ApplySyntax/as_plugins/is_rails_file , but it is recommended to use the dot notation as it makes more sense from a Python import perspective. The second parameter is args and is optional. args is a dictionary of the keyword arguments the function rule plugin accepts. The plugin must have a function defined as syntax_test . syntax_test will be the function called within the plugin file and accepts an argument file_path (which is the full path to the file being evaluated), and any custom keyword arguments desired by the user. The plugin must return either True or False . { \"function\" : { \"source\" : \"User.plugins.myplugin\" , \"args\" : { 'foo' : \"bar\" }}} Example: def syntax_test ( file_path , foo ): # Some test logic return False # True or False Tip When placing a function rule module in a package, it is advised to put it in a sub-folder. The sub-folder does not need an __init__.py , it just needs your module(s).","title":"Function Rule"},{"location":"usage/#content-rule","text":"Sometimes a file name or first line search is just not enough and maybe a function rule is overkill. In this case, maybe searching the content of a file can be enough. You can search a file's content with regex for a specific token via the contains rule. { \"contains\" : \"<script [^>]*type=\\\"text\\\\/x-handlebars\\\"[^>]*>\" } Tip It is recommended to pair contains rules with other rules via the \"match\" : \"all\" option to ensure you don't search every file (which can significantly slow down the editor); this will also help ensure get more reliable matches. If pairing with other rules as dependencies, it is advised to pair the contains rule after the other required rule(s) to ensure you search the content of as few files as possible. Also, try to use very specific regex to ensure you don't get false positives.","title":"Content Rule"},{"location":"usage/#extension-trimming","text":"Sometimes a file may have a trailing extension that prevents it from matching a rule, but if it was trimmed off, it would match. By creating an extension trimming rule, you target files that do not initial match and send them back through the pipe without it's last extension. Currently, an extension trimming rule only contains a file_path pattern. \"ext_trim\" : [{ \"file_path\" : \".*\\\\.py3\\\\.temp\" }] You can also use globmatch patterns: \"ext_trim\" : [{ \"globmatch\" : \"**/*.py3.temp\" }] So, if we had a file named test.py3.temp , it normally wouldn't match one of default rules. With the above rule, the file would be retried as test.py3 and would match the Python syntax rule. New 4.0 globmatch support was added in 4.0. Changed 4.0 On Windows systems, paths are now normalized to from using \\ to / . This makes creating patterns for cross platform use much easier, but it may break some existing rules in the short term.","title":"Extension Trimming"},{"location":"usage/#project-specific-rules","text":"To define project specific syntaxes, just create a settings key in your project file (if it doesn't already exist) and then and an additional key under settings called project_syntaxes or project_ext_trim . project_syntaxes is an array; just add your syntax rules to project_syntaxes just like you would add them to syntaxes in your user settings file, and ApplySyntax will prepend the rules to the beginning of your defined rules. The order of rules is as follows: project \u2192 user \u2192 default. project_ext_trim is also an array, and you can trim rules just as you would to ext_trim in your user settings file. There is one difference between project specific rules and global rules. In project rules, the extensions key will not be applied to the associated syntax language settings file as project specific rules are not global, but language settings files are global. \"settings\" : { \"project_syntaxes\" : [ { \"syntax\" : \"XML/XML\" , \"rules\" : [ { \"file_path\" : \".*\\\\.xml(\\\\.dist)?$\" }, { \"first_line\" : \"^<\\\\?xml\" } ] } ], \"project_ext_trim\" : [ { \"file_path\" : \".*\\\\.file.temp\" } ] }","title":"Project Specific Rules"},{"location":"usage/#settings-options","text":"There are a couple of general settings found in ApplySyntax.sublime-settings .","title":"Settings Options"},{"location":"usage/#re-raise-exceptions","text":"If an exception occurs when processing a function, this will re-raised the captured exception in Sublime's console so the user get feedback. This is really only useful to those writing functions. The average user shouldn't need this. By default, the setting will be set to false . \"reraise_exceptions\" : false ,","title":"Re-Raise Exceptions"},{"location":"usage/#new-file-syntax","text":"If you want to have a syntax applied when new files are created, set new_file_syntax to the name of the syntax to use. The format is exactly the same as the syntax parameter in the syntax rules mentioned earlier. For example, if you want to have a new file use JavaScript syntax, set new_file_syntax to JavaScript/JavaScript . The default is false . \"new_file_syntax\" : \"JavaScript/JavaScript\" ,","title":"New File Syntax"},{"location":"usage/#add-extensions-to-language-settings","text":"To enable adding defined extensions to language settings, just set add_exts_to_lang_settings to true . See Extensions for more info. \"add_exts_to_lang_settings\" : true ,","title":"Add Extensions to Language Settings"},{"location":"usage/#troubleshooting-and-debugging","text":"By default, the debug setting is turned on so that users have some form of visual feedback in the console that ApplySyntax is working. This can be turned off by setting debug to false . If developing, you can set debug to verbose to get even more info in the console. // Control level of logging in the console. // (true|false|\"verbose\") \"debug\" : true ,","title":"Troubleshooting and Debugging"},{"location":"about/changelog/","text":"ApplySyntax 4.0.3 FIX : Recent versions of Sublime have the JSON syntax file in a new place. FIX : Add .babelrc and .stylelintrc to JSON rule. FIX : Reduce dependencies as they are all not required anymore. FIX : Support dialog did not show all relevant dependencies. FIX : New location for Ruby syntax files in later Sublime versions. 4.0.2 FIX : Fix Gemfile.lock being detected as Ruby on Rails. ( #148 ) 4.0.1 FIX : \"Browse Syntaxes\" should show legacy tmLanguage files as well as the new sublime-syntax . 4.0.0 NEW : All file names are now normalized to / , so regex patterns should no longer use \\ to specify path separators for Windows. Please update your patterns personal patterns to use / in the settings file instead of the double escaped backslashes ( \\\\\\\\ ). This applies to file_path rule patterns and ext_trim patterns. NEW : Add new globmatch rule. NEW : Add new apply_syntax_browse command in the command palette to browse all syntaxes. When one is selected, the syntax will be copied to the clipboard in a form compatible to be used in a syntax rule. NEW : Add new apply_syntax_current command which will copy the current active view's syntax to the clipboard in a form compatible to be used in a syntax rule. 3.0.1 FIX : Avoid evaluating path if it is None. 3.0.0 NEW : Remove deprecations. NEW : Add feature to allow configurable trimming of a file's extension and retry syntax detection if file path fails initial detection. ( #132 ) 2.5.5 FIX : Fix check for unsaved buffer. 2.5.4 FIX : Fix extension compare and order of evaluation. 2.5.3 FIX : Use proper Bash syntax. FIX : Use proper Git syntax. ( !119 ) 2.5.2 FIX : Update shell scripts to use newest Bash language file. 2.5.1 FIX : Update Rspec rule with RSpec Buddy/RSpec Buddy . 2.5.0 NEW : Add document and settings command to command palette. FIX : Handling of list syntax. 2.4.1 FIX : Fix usage of deprecated key name in default settings. 2.4.0 NEW : Added TypoScript rules. NEW : Restrict phantoms to 3124+. NEW : Support commands. 2.3.1 FIX : Configuration tweaks to YAML rules. 2.3.0 NEW : Added changelog command. NEW : Added support command. FIX : Fix issue where new_file_syntax would occasionally not work #100 .","title":"Changelog"},{"location":"about/changelog/#applysyntax","text":"","title":"ApplySyntax"},{"location":"about/changelog/#403","text":"FIX : Recent versions of Sublime have the JSON syntax file in a new place. FIX : Add .babelrc and .stylelintrc to JSON rule. FIX : Reduce dependencies as they are all not required anymore. FIX : Support dialog did not show all relevant dependencies. FIX : New location for Ruby syntax files in later Sublime versions.","title":"4.0.3"},{"location":"about/changelog/#402","text":"FIX : Fix Gemfile.lock being detected as Ruby on Rails. ( #148 )","title":"4.0.2"},{"location":"about/changelog/#401","text":"FIX : \"Browse Syntaxes\" should show legacy tmLanguage files as well as the new sublime-syntax .","title":"4.0.1"},{"location":"about/changelog/#400","text":"NEW : All file names are now normalized to / , so regex patterns should no longer use \\ to specify path separators for Windows. Please update your patterns personal patterns to use / in the settings file instead of the double escaped backslashes ( \\\\\\\\ ). This applies to file_path rule patterns and ext_trim patterns. NEW : Add new globmatch rule. NEW : Add new apply_syntax_browse command in the command palette to browse all syntaxes. When one is selected, the syntax will be copied to the clipboard in a form compatible to be used in a syntax rule. NEW : Add new apply_syntax_current command which will copy the current active view's syntax to the clipboard in a form compatible to be used in a syntax rule.","title":"4.0.0"},{"location":"about/changelog/#301","text":"FIX : Avoid evaluating path if it is None.","title":"3.0.1"},{"location":"about/changelog/#300","text":"NEW : Remove deprecations. NEW : Add feature to allow configurable trimming of a file's extension and retry syntax detection if file path fails initial detection. ( #132 )","title":"3.0.0"},{"location":"about/changelog/#255","text":"FIX : Fix check for unsaved buffer.","title":"2.5.5"},{"location":"about/changelog/#254","text":"FIX : Fix extension compare and order of evaluation.","title":"2.5.4"},{"location":"about/changelog/#253","text":"FIX : Use proper Bash syntax. FIX : Use proper Git syntax. ( !119 )","title":"2.5.3"},{"location":"about/changelog/#252","text":"FIX : Update shell scripts to use newest Bash language file.","title":"2.5.2"},{"location":"about/changelog/#251","text":"FIX : Update Rspec rule with RSpec Buddy/RSpec Buddy .","title":"2.5.1"},{"location":"about/changelog/#250","text":"NEW : Add document and settings command to command palette. FIX : Handling of list syntax.","title":"2.5.0"},{"location":"about/changelog/#241","text":"FIX : Fix usage of deprecated key name in default settings.","title":"2.4.1"},{"location":"about/changelog/#240","text":"NEW : Added TypoScript rules. NEW : Restrict phantoms to 3124+. NEW : Support commands.","title":"2.4.0"},{"location":"about/changelog/#231","text":"FIX : Configuration tweaks to YAML rules.","title":"2.3.1"},{"location":"about/changelog/#230","text":"NEW : Added changelog command. NEW : Added support command. FIX : Fix issue where new_file_syntax would occasionally not work #100 .","title":"2.3.0"},{"location":"about/contributing/","text":"Contributing & Support Overview Sublime Versions Description ST2 <= version < ST3 Supported on a separate branch, but not actively. Any further fixes or enhancements must come from the community. Issues for versions less than ST3 will not be addressed moving forward by me. Pull requests are welcome for back-porting features, enhancements, or fixes to the old branch, but the content of the pull must already exist on the main, actively developed branch. I will not allow an older branch to exceed the main branch in regards to functionality. ST3 Fully supported and actively maintained. Contribution from the community is encouraged and can be done in a variety of ways: Become a sponsor. Bug reports. Reviewing code. Code patches via pull requests. Documentation improvements via pull requests. Become a Sponsor Open source projects take time and money. Help support the project by becoming a sponsor. You can add your support at any tier you feel comfortable with. No amount is too little. We also accept one time contributions via PayPal. GitHub Sponsors PayPal Bug Reports Please read the documentation and search the issue tracker to try to find the answer to your question before posting an issue. When creating an issue on the repository, please provide as much info as possible: Provide environment information by running Preferences->Package Settings->ApplySyntax->Support Info . The information will be copied to the clipboard; paste the info in issue. Errors in console. Detailed description of the problem. Examples for reproducing the error. You can post pictures, but if specific text or code is required to reproduce the issue, please provide the text in a plain text format as well for easy copy/paste. The more info provided the greater the chance someone will take the time to answer, implement, or fix the issue. Be prepared to answer questions and provide additional information if required. Issues in which the creator refuses to respond to follow up questions will be marked as stale and closed. Reviewing Code Take part in reviewing pull requests and/or reviewing direct commits. Make suggestions to improve the code and discuss solutions to overcome weakness in the algorithm. Pull Requests Pull requests are welcome, and if you plan on contributing directly to the code, there are a couple of things to be mindful of. Please describe the change in as much detail as possible so I can understand what is being added or modified. If you are solving a bug that does not already have an issue, please describe the bug in detail and provide info on how to reproduce if applicable (this is good for me and others to reference later when verifying the issue has been resolved). Please reference and link related open bugs or feature requests in this pull if applicable. Make sure you've documented or updated the existing documentation if introducing a new feature or modifying the behavior of an existing feature that a user needs to be aware of. I will not accept new features or changes to existing features if you have not provided documentation describing the feature. Continuous integration tests on are run on all pull requests and commits via Travis CI. When making a pull request, the tests will automatically be run, and the request must pass to be accepted. You can (and should) run these tests before pull requesting. If it is not possible to run these tests locally, they will be run when the pull request is made, but it is strongly suggested that requesters make an effort to verify before requesting to allow for a quick, smooth merge. Running Validation Tests Tip If you are running Sublime on a macOS or Linux/Unix system, you run all tests by by running the shell script (assuming you have installed your environment fulfills all requirements below): chmod +x run_tests.sh ./run_tests.sh There are a couple of dependencies that must be present before running the tests. As ST3 is the only current, actively supported version, Python 3.3 must be used to validate the tests. Unit tests are run with pytest . You can install pytest via: pip install pytest The tests should be run from the root folder of the plugin by using the following command: py.test . Linting is performed on the entire project with flake8 , flake8_docstrings , pep8-naming . These can be installed via: pip install flake8 pip install flake8_docstrings pip install pep8-naming Linting is performed with the following command: flake8 . Documentation Improvements A ton of time has been spent not only creating and supporting this plugin, but also spent making this documentation. If you feel it is still lacking, show your appreciation for the plugin by helping to improve the documentation. Help with documentation is always appreciated and can be done via pull requests. There shouldn't be any need to run validation tests if only updating documentation. You don't have to render the docs locally before pull requesting, but if you wish to, I currently use a combination of MkDocs , the Material theme , and PyMdown Extensions to render the docs. You can preview the docs if you install these two packages. The command for previewing the docs is mkdocs serve from the root directory. You can then view the documents at localhost:8000 .","title":"Contributing &amp; Support"},{"location":"about/contributing/#contributing--support","text":"","title":"Contributing &amp; Support"},{"location":"about/contributing/#overview","text":"Sublime Versions Description ST2 <= version < ST3 Supported on a separate branch, but not actively. Any further fixes or enhancements must come from the community. Issues for versions less than ST3 will not be addressed moving forward by me. Pull requests are welcome for back-porting features, enhancements, or fixes to the old branch, but the content of the pull must already exist on the main, actively developed branch. I will not allow an older branch to exceed the main branch in regards to functionality. ST3 Fully supported and actively maintained. Contribution from the community is encouraged and can be done in a variety of ways: Become a sponsor. Bug reports. Reviewing code. Code patches via pull requests. Documentation improvements via pull requests.","title":"Overview"},{"location":"about/contributing/#become-a-sponsor","text":"Open source projects take time and money. Help support the project by becoming a sponsor. You can add your support at any tier you feel comfortable with. No amount is too little. We also accept one time contributions via PayPal. GitHub Sponsors PayPal","title":"Become a Sponsor "},{"location":"about/contributing/#bug-reports","text":"Please read the documentation and search the issue tracker to try to find the answer to your question before posting an issue. When creating an issue on the repository, please provide as much info as possible: Provide environment information by running Preferences->Package Settings->ApplySyntax->Support Info . The information will be copied to the clipboard; paste the info in issue. Errors in console. Detailed description of the problem. Examples for reproducing the error. You can post pictures, but if specific text or code is required to reproduce the issue, please provide the text in a plain text format as well for easy copy/paste. The more info provided the greater the chance someone will take the time to answer, implement, or fix the issue. Be prepared to answer questions and provide additional information if required. Issues in which the creator refuses to respond to follow up questions will be marked as stale and closed.","title":"Bug Reports"},{"location":"about/contributing/#reviewing-code","text":"Take part in reviewing pull requests and/or reviewing direct commits. Make suggestions to improve the code and discuss solutions to overcome weakness in the algorithm.","title":"Reviewing Code"},{"location":"about/contributing/#pull-requests","text":"Pull requests are welcome, and if you plan on contributing directly to the code, there are a couple of things to be mindful of. Please describe the change in as much detail as possible so I can understand what is being added or modified. If you are solving a bug that does not already have an issue, please describe the bug in detail and provide info on how to reproduce if applicable (this is good for me and others to reference later when verifying the issue has been resolved). Please reference and link related open bugs or feature requests in this pull if applicable. Make sure you've documented or updated the existing documentation if introducing a new feature or modifying the behavior of an existing feature that a user needs to be aware of. I will not accept new features or changes to existing features if you have not provided documentation describing the feature. Continuous integration tests on are run on all pull requests and commits via Travis CI. When making a pull request, the tests will automatically be run, and the request must pass to be accepted. You can (and should) run these tests before pull requesting. If it is not possible to run these tests locally, they will be run when the pull request is made, but it is strongly suggested that requesters make an effort to verify before requesting to allow for a quick, smooth merge.","title":"Pull Requests"},{"location":"about/contributing/#running-validation-tests","text":"Tip If you are running Sublime on a macOS or Linux/Unix system, you run all tests by by running the shell script (assuming you have installed your environment fulfills all requirements below): chmod +x run_tests.sh ./run_tests.sh There are a couple of dependencies that must be present before running the tests. As ST3 is the only current, actively supported version, Python 3.3 must be used to validate the tests. Unit tests are run with pytest . You can install pytest via: pip install pytest The tests should be run from the root folder of the plugin by using the following command: py.test . Linting is performed on the entire project with flake8 , flake8_docstrings , pep8-naming . These can be installed via: pip install flake8 pip install flake8_docstrings pip install pep8-naming Linting is performed with the following command: flake8 .","title":"Running Validation Tests"},{"location":"about/contributing/#documentation-improvements","text":"A ton of time has been spent not only creating and supporting this plugin, but also spent making this documentation. If you feel it is still lacking, show your appreciation for the plugin by helping to improve the documentation. Help with documentation is always appreciated and can be done via pull requests. There shouldn't be any need to run validation tests if only updating documentation. You don't have to render the docs locally before pull requesting, but if you wish to, I currently use a combination of MkDocs , the Material theme , and PyMdown Extensions to render the docs. You can preview the docs if you install these two packages. The command for previewing the docs is mkdocs serve from the root directory. You can then view the documents at localhost:8000 .","title":"Documentation Improvements"},{"location":"about/license/","text":"License Raw Line Edit is released under the MIT license. Copyright \u00a9 phillipkoebbe. Changes: Copyright \u00a9 2013 - 2022 Isaac Muse isaacmuse@gmail.com Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"about/license/#license","text":"Raw Line Edit is released under the MIT license. Copyright \u00a9 phillipkoebbe. Changes: Copyright \u00a9 2013 - 2022 Isaac Muse isaacmuse@gmail.com Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"}]}